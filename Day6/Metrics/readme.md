# Monitoring

## Metrics vs Monitoring

Metrics are measurements or data points that tell you what is happening. For example, the number of steps you walk each day, your heart rate, or the temperature outside‚Äîthese are all metrics.

Monitoring is the process of keeping an eye on these metrics over time to understand what‚Äôs normal, identify changes, and detect problems. It's like watching your step count daily to see if you're meeting your fitness goal or checking your heart rate to make sure it's in a healthy range.

## üöÄ Prometheus
- Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud.
- It is known for its robust data model, powerful query language (PromQL), and the ability to generate alerts based on the collected time-series data.
- It can be configured and set up on both bare-metal servers and container environments like Kubernetes.

## üè† Prometheus Architecture
- The architecture of Prometheus is designed to be highly flexible, scalable, and modular.
- It consists of several core components, each responsible for a specific aspect of the monitoring process.

![Prometheus Architecture](images/prometheus-architecture.gif)

### üî• Prometheus Server
- Prometheus server is the core of the monitoring system. It is responsible for scraping metrics from various configured targets, storing them in its time-series database (TSDB), and serving queries through its HTTP API.
- Components:
    - **Retrieval**: This module handles the scraping of metrics from endpoints, which are discovered either through static configurations or dynamic service discovery methods.
    - **TSDB (Time Series Database)**: The data scraped from targets is stored in the TSDB, which is designed to handle high volumes of time-series data efficiently.
    - **HTTP Server**: This provides an API for querying data using PromQL, retrieving metadata, and interacting with other components of the Prometheus ecosystem.
- **Storage**: The scraped data is stored on local disk (HDD/SSD) in a format optimized for time-series data.

### üåê Service Discovery
- Service discovery automatically identifies and manages the list of scrape targets (i.e., services or applications) that Prometheus monitors.
- This is crucial in dynamic environments like Kubernetes where services are constantly being created and destroyed.
- Components:
    - **Kubernetes**: In Kubernetes environments, Prometheus can automatically discover services, pods, and nodes using Kubernetes API, ensuring it monitors the most up-to-date list of targets.
    - **File SD (Service Discovery)**: Prometheus can also read static target configurations from files, allowing for flexibility in environments where dynamic service discovery is not used.

### üì§ Pushgateway
- The Pushgateway is used to expose metrics from short-lived jobs or applications that cannot be scraped directly by Prometheus.
- These jobs push their metrics to the Pushgateway, which then makes them available for Prometheus to scrape(pull).
- Use Case:
    - It's particularly useful for batch jobs or tasks that have a limited lifespan and would otherwise not have their metrics collected.

### üö® Alertmanager
- The Alertmanager is responsible for managing alerts generated by the Prometheus server.
- It takes care of deduplicating, grouping, and routing alerts to the appropriate notification channels such as PagerDuty, email, or Slack.

### üß≤ Exporters
- Exporters are small applications that collect metrics from various third-party systems and expose them in a format Prometheus can scrape. They are essential for monitoring systems that do not natively support Prometheus.
- Types of Exporters:
    - Common exporters include the Node Exporter (for hardware metrics), the MySQL Exporter (for database metrics), and various other application-specific exporters.

### üñ•Ô∏è Prometheus Web UI
- The Prometheus Web UI allows users to explore the collected metrics data, run ad-hoc PromQL queries, and visualize the results directly within Prometheus.

### üìä Grafana
- Grafana is a powerful dashboard and visualization tool that integrates with Prometheus to provide rich, customizable visualizations of the metrics data.

### üîå API Clients
- API clients interact with Prometheus through its HTTP API to fetch data, query metrics, and integrate Prometheus with other systems or custom applications.



# üìà Prometheus Monitoring and PromQL Guide

This document serves as a quick reference for understanding the core concepts of Prometheus, including **Metrics**, **Labels**, and the **Prometheus Query Language (PromQL)**.

---

## üìä Core Data Concepts

### 1. Metrics
Metrics are the fundamental data objects in Prometheus. They are **measurements** collected from monitored systems that provide insight into various aspects of system performance, health, and behavior (e.g., CPU usage, request count, error rates).

### 2. Labels (Dimensionality)
Labels are **key-value pairs** that are attached to a metric. They add dimension to a metric, allowing you to filter and aggregate data based on characteristics like service name, instance ID, endpoint, or namespace.

#### üè∑Ô∏è Example of a Time Series:
| Component | Example | Role |
| :--- | :--- | :--- |
| **Metric Name** | `container_cpu_usage_seconds_total` | The quantity being measured. |
| **Labels** | `{namespace="kube-system", endpoint="https-metrics"}` | Dimensions of the measurement. |

---

## üõ†Ô∏è PromQL (Prometheus Query Language)

**PromQL** is a powerful and flexible functional query language used to retrieve, manipulate, and analyze time series data from Prometheus.

### üîë Key PromQL Features

* **Selecting Time Series:** Retrieving data based on metric name and label matching.
* **Mathematical Operations:** Performing arithmetic and logical operations on metrics.
* **Aggregation:** Combining data from multiple time series using functions like `sum`, `avg`, `max`, etc.
* **Functions:** Applying a wide range of analytical functions (`rate()`, `increase()`, `histogram_quantile()`) to the data.

### üí° PromQL Query Types

PromQL operates on two main types of data vectors:

#### A. Instant Vector (Instantaneous Value)
An Instant Vector returns a set of time series, each with a single sample value, at the precise time of the query.

| Query | Description |
| :--- | :--- |
| `container_cpu_usage_seconds_total` | Returns the latest sample for **all** time series of this metric. |
| `kube_pod_container_status_restarts_total{pod="crashing-pod"}` | Returns the current restart count for the specified Pod/container. |

#### B. Range Vector (Historical Range)
A Range Vector returns a set of time series, each containing a range of sample values over a specified time duration, denoted by the time range suffix (e.g., `[5m]`).

| Query | Description |
| :--- | :--- |
| `kube_configmap_created{namespace="kube-system"}` | Returns the **latest timestamp** for the ConfigMaps in `kube-system`. |
| `container_cpu_usage_seconds_total[5m]` | Returns all samples collected within the last **5 minutes** for the metric. |

---

## ‚öôÔ∏è Advanced PromQL Functions and Aggregation

These functions are critical for transforming raw counter data into meaningful rates or aggregating data across the cluster.

### 1. Rate and Counter Functions

| Function | Example Query | Purpose |
| :--- | :--- | :--- |
| **`rate()`** | `rate(container_cpu_usage_seconds_total[5m])` | Calculates the **per-second average rate** of increase over the specified 5-minute time range. Essential for converting raw counter metrics (like `_total`) into usage rates (e.g., CPU seconds per second). |
| **`increase()`** | `increase(kube_pod_container_status_restarts_total[1h])` | Returns the **total increase in value** over the specified time range. Useful for showing the raw count of events (like restarts) that occurred in the last hour. |
| **`histogram_quantile()`** | `histogram_quantile(0.95, sum(rate(apiserver_request_duration_seconds_bucket[5m])) by (le))` | Calculates the **95th percentile** of observed latency from Prometheus histogram data. |

### 2. Aggregation Operators (`sum`, `avg`, `by`)

Aggregation is used to collapse multiple time series into fewer time series by calculating a summary statistic.

| Query | Description |
| :--- | :--- |
| `sum(rate(node_cpu_seconds_total[5m]))` | Sums the CPU rate across **all** nodes (total cluster usage). |
| `avg(container_memory_usage_bytes) by (namespace)` | Calculates the **average memory usage**, grouping the result by the `namespace` label. |
| `sum(rate(node_cpu_seconds_total[5m])) by (instance)` | Calculates the total CPU rate per **individual node instance**. |

---

## ‚ö†Ô∏è Example Debugging PromQL

To analyze the constantly crashing pod created by the command:
`kubectl run crashing-pod --image=busybox --restart=Always -- /bin/false`

| Query | Output Interpretation |
| :--- | :--- |
| `increase(kube_pod_container_status_restarts_total{pod="crashing-pod"}[5m])` | A non-zero, rising value here **confirms constant container crashing** due to the short lifespan of the `/bin/false` command, indicating a `CrashLoopBackOff`. |